class Z(object):
    def __init__(self, a):
        self.a = a

    def __neg__(x):
        return Z(-x.a)

    def __mul__(x, y):
        return Z(x.a * y.a)

    def __div__(x, y):
        return Z(x.a / y.a)

    def __mod__(x, y):
        return Z(x.a % y.a)

    def __add__(x, y):
        return Z(x.a + y.a)

    def __sub__(x, y):
        return Z(x.a - y.a)

    def __str__(self):
        return str(self.a)

    def __eq__(x, y):
        return x.a == y.a

    def __ne__(x, y):
        return x.a != y.a

    def __lt__(x, y):
        return x.a < y.a

    def __gt__(x, y):
        return x.a > y.a

    def isUnit(self):
        return (self.a == 1) or (self.a == -1)

    @staticmethod
    def getZero():
        return Z(0)

    @staticmethod
    def getOne():
        return Z(1)

    def factor(self):
        factors = []
        aCopy = self.a
        currentFactor = 2
        while currentFactor <= float(aCopy):
            if aCopy % currentFactor == 0:
                factors.append(Z(currentFactor))
                aCopy /= currentFactor
            else:
                currentFactor += 1
        if aCopy > 1:
            factors.append(Z(currentFactor))
        return factors


class ZI(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __neg__(x):
        return ZI(-x.a, -x.b)

    def __mul__(x, y):
        return ZI(x.a * y.a - x.b * y.b, x.a * y.b + x.b * y.a)

    def __add__(x, y):
        return ZI(x.a + y.a, x.b + y.b)

    def __sub__(x,y):
        return ZI(x.a - y.a, x.b - y.b)

    def __lt__(x, y):
        return (x.a * x.a + x.b * x.b) < (y.a * y.a + y.b * y.b)

    def __gt__(x, y):
        return (x.a * x.a + x.b * x.b) > (y.a * y.a + y.b * y.b)

    def __str__(self):
        return str(self.a) + "+(" + str(self.b) + ")i"

    def __eq__(x, y):
        return x.a == y.a and x.b == y.b

    def __ne__(x, y):
        return not x == y

    def com(x):
        return ZI(x.a,-x.b)

    def num(x,y):
        return ZI((x*y.com()).a,(x*y.com()).b)

    def __div__(x,y):
        return ZI(round(float((x.num(y)).a) / (y.a*y.a + y.b*y.b)),round(float((x.num(y)).b) / (y.a*y.a + y.b*y.b)))

    def __mod__(x,y):
        return ZI((x - y * (x / y)).a,(x - y * (x / y)).b)

    def isUnit(self):
        return (self.a==1) or (self.a==-1)

    @staticmethod
    def getZero():
        return Z(0)
    
    @staticmethod
    def getOne():
        return Z(1)

    def factor(self):
        factors = []
        aCopy = self.a
        currentFactor = 2
        while currentFactor <= float(aCopy):
            if aCopy % currentFactor == 0:
                factors.append(Z(currentFactor))
                aCopy /= currentFactor
            else:
                currentFactor += 1
        if aCopy > 1:
            factors.append(Z(currentFactor))
        return factors

class ZI(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __neg__(x):
        return ZI(-x.a, -x.b)

    def __mul__(x,y):
        return ZI(x.a*y.a - x.b*y.b, x.a*y.b + x.b*y.a)

    def __add__(x,y):
        return ZI(x.a + y.a, x.b + y.b)

    def __lt__(x,y):
        return (x.a*x.a + x.b*x.b) < (y.a*y.a + y.b*y.b)

    def __gt__(x,y):
        return (x.a*x.a + x.b*x.b) > (y.a*y.a + y.b*y.b)

    def __str__(self):
        return str(self.a) + "+(" + str(self.b)+")i"

    def __eq__(x,y):
        return x.a == y.a and x.b == y.b

    def __ne__(x,y):
        return not x == y

    def isUnit(self):
        if self.a==1 and self.b==0:
            return True
        elif self.a==-1 and self.b==0:
            return True
        elif self.a==0 and self.b==1:
            return True
        elif self.a==0 and self.b==-1:
            return True
        return False

    @staticmethod
    def getZero():
        return ZI(0,0)

    @staticmethod
    def getOne():
        return ZI(1,0)

    def factor(self):
        #TODO
        return []

class Matrix(object):
    def __init__(self, h, w, elements):
        self.h = h
        self.w = w
        self.elements = elements

    def __add__(x, y):
        assert x.h == y.h
        assert x.w == y.w
        newElements = []
        for i in range(h*w):
            newElements.append(x.elements[i] + y.elements[i])
        return Matrix(x.h, x.w, newElements)

    def __mul__(x, y):
        assert x.w == y.h
        newH = x.h
        newW = y.w
        newElements = []
        for i in range(newH):
            for j in range(newW):
                newElement = x.elements[0].getZero();
                for k in range(x.w):
                    newElement += (x.get(i, k) * y.get(k, j))
                newElements.append(newElement)
        return Matrix(newH, newW, newElements)

    def __str__(self):
        result = ""
        for i in range(self.h):
            for j in range(self.w):
                result += (str(self.get(i,j)) + " ")
            result += "\n"
        return result

    def __eq__(x,y):
        if x.h != y.h or x.w != y.w:
            return False
        for i in range(x.w * x.h):
            if x.elements[i] != y.elements[i]:
                return False
        return True

    def __ne__(x,y):
        return not x == y

    @staticmethod
    def id(dim, elementType):
        elements = [elementType.getZero() for i in range(dim*dim)]
        for i in range(dim):
            elements[i*dim + i] = elementType.getOne()
        return Matrix(dim, dim, elements)

    def get(self, i, j):
        assert i>=0 and i<self.h
        assert j>=0 and j<self.w
        return self.elements[i*self.w + j]

    def set(self, i, j, e):
        assert i>=0 and i<self.h
        assert j>=0 and j<self.w
        self.elements[i*self.w + j] = e

    def copy(self):
        return Matrix(self.h, self.w, self.elements[:])

    @staticmethod
    def inputMatrix():
        print "What type is your matrix?"
        print "[0]: Integers"
        print "[1]: Gaussian Integers"
        choice = int(raw_input("> "))

        #-------- Integers -----------#
        if (choice==0):
            print 
            h = int(raw_input("Matrix height: "))
            assert h>0
            w = int(raw_input("Matrix width:  "))
            assert w>0
            strElements = raw_input("Please enter the %d comma-delineated matrix elements across rows\n"%(h*w)).split(",")
            print
            contents = []
            for i in range(len(strElements)):
                contents.append(Z(int(strElements[i].strip())))

            return Matrix(h,w,contents)
            

        #----- Gaussian Integers -----#
        elif (choice ==1):
            print "Not Yet Supported"
            print

        else:
            print "Sorry. That was not a valid selection."
            print


            

# We should find that every through the process S*A*T = J where
# A is the input matrix.
#
# These matrices should only be accessed by the helper methods
# These matrices are defined here so that they are in global 
# scope and can be accessed by the helper methods.

elementT = None;
S = None;
J = None;
T = None;

def cSwap(i,j):
    global elementT, S, J, T
    print "OPERATION: Swapping columns %d and %d"%(i,j)
    #perform the column swap to J
    assert J is not None
    for k in range(J.h):
        temp = J.get(k, i)
        J.set(k,i,J.get(k,j))
        J.set(k,j, temp)
    assert J is not None

    #adjust the T matrix
    adjustment = Matrix.id(T.h, elementT)
    adjustment.set(i,j,elementT.getOne())
    adjustment.set(j,i,elementT.getOne())
    adjustment.set(i,i,elementT.getZero())
    adjustment.set(j,j,elementT.getZero())
    print "adjustment:"
    print adjustment
    T = T*adjustment
    print "adjusted T:"
    print T

def cLC(i,j,a,b):
    global elementT, S, J, T
    print "OPERATION: Column %d gets %s column %d plus %s column %d"%(i,a,i,b,j)
    assert a is not 0 and b is not 0
    #perform the linear column application to J
    for k in range(J.h):
        J.set(k,i,a*J.get(k,i) + b*J.get(k,j))

    #adjust the T matrix
    adjustment = Matrix.id(T.h, elementT)
    adjustment.set(i,i,a)
    if i!=j:
        adjustment.set(j,i,b) 
    print "adjustment:"
    print adjustment
    T = T*adjustment
    print "adjusted T:"
    print T

def rSwap(i,j):
    global elementT, S, J, T
    print "OPERATION: Swapping rows %d and %d"%(i,j)
    #perform the row swap to J
    for k in range(J.w):
        temp = J.get(i, k)
        J.set(i,k,J.get(j,k))
        J.set(j,k, temp)

    #adjust the S matrix
    adjustment = Matrix.id(S.h, elementT)
    adjustment.set(i,j,elementT.getOne())
    adjustment.set(j,i,elementT.getOne())
    adjustment.set(i,i,elementT.getZero())
    adjustment.set(j,j,elementT.getZero())
    print "adjustment:"
    print adjustment
    S = adjustment*S
    print "adjusted S:"
    print S

def rLC(i,j,a,b):
    global elementT, S, J, T
    print "OPERATION: Row %d gets %s row %d plus %s row %d"%(i,a,i,b,j)
    assert a is not 0 and b is not 0
    #perform the linear column application to J
    for k in range(J.w):
        J.set(i,k,a*J.get(i,k) + b*J.get(j,k))

    #adjust the S matrix
    adjustment = Matrix.id(S.h, elementT)
    adjustment.set(i,i,a)
    if i!=j:
        adjustment.set(i,j,b) 
    print "adjustment:"
    print adjustment
    S = adjustment*S
    print "adjusted S:"
    print S

def euclid(a, b):
    # output g, x, y where g = gcd(a,b) = xa + yb
    x0 = type(b).getOne()
    x1 = type(b).getZero()
    y0 = type(b).getZero()
    y1 = type(b).getOne()
    while b != type(b).getZero():
        tempa = a
        tempb = b
        q = tempa / tempb
        a = tempb
        b = tempa % tempb
        tempx0 = x0
        x0 = x1
        x1 = tempx0 - q * x0
        tempy0 = y0
        y0 = y1
        y1 = tempy0 - q * y0
    assert a is not None
    assert x0 is not None
    assert y0 is not None
    return [a, x0, y0]


def snf(A):
    global elementT, J, S, T
    J = A.copy()
    elementT=type(A.get(0,0))

    assert J is not None
    assert elementT is not None

    print "Calculating the Smith Normal Form..."
    print
    print "J: "
    print J
    print

    S = Matrix.id(A.h, type(A.get(0,0)))
    T = Matrix.id(A.w, type(A.get(0,0)))

    #The heart of snf starts here
    for i in range(min(J.h,J.w)):
        print "starting %d iteration"%i
        #if the top-left element of the subarray is 0 we need to
        #perform row/column swaps to move in a different value
        if J.get(i,i) == elementT.getZero():
            #we search for a nonzero entry in the submatrix to replace the
            #zero element with. 
            foundReplacement = False;
            for j in range(i, J.h):
                if foundReplacement:
                    break
                for k in range(i,J.w):
                    if (J.get(j,k) != elementT.getZero()):
                        foundReplacement = True
                        break
            #if there are no non-zero values left to swap in, the algorithm
            #is complete
            if not foundReplacement:
                assert (J is not None) and (str(J) is not None)
                return J
            #perform the swap
            else:
                rSwap(i,j)
                cSwap(i,k)
        #now we should not have a zero in the top-left position
        #of the submatrix
        assert J.get(i,i) != elementT.getZero()
        assert (J is not None) and (str(J) is not None)

        #make the top-left submatrix element be the gcd of all the elements
        #in the same row or the same column
        gcd=J.get(i,i)
        doneIteration = False
        while not doneIteration:
            doneIteration = True
            for j in range(i+1, J.h):
                gcd, x, y = euclid(J.get(i,i), J.get(j,i))
                if (gcd < elementT.getZero()):
                    gcd = -gcd
                    x = -x
                    y = -y
                #print gcd, J.get(j,i)
                if gcd == J.get(j,i):
                    rSwap(i,j)
                    print "J:"
                    print J
                    print 
                    doneIteration=False
                elif gcd == -J.get(j,i): #TODO WORK THIS BLOCK
                    rSwap(i,j)
                    rLC(i,i,-elementT.getOne(), elementT.getZero())
                    print "J:"
                    print J
                    print 
                    doneIteration=False
                elif gcd.a < J.get(i,i).a:
                    rLC(i, j, x, y)
                    print "J:"
                    print J
                    print 
                    doneIteration=False
            for j in range(i+1, J.w):
                gcd, x, y = euclid(J.get(i,i), J.get(i,j))
                if (gcd < elementT.getZero()):
                    gcd = -gcd
                    x = -x
                    y = -y
                #print gcd, J.get(i,j)
                if gcd == J.get(i,j):
                    cSwap(i,j)
                    print "J:"
                    print J
                    print 
                    doneIteration=False
                elif gcd == -J.get(i,j): #TODO WORK THIS BLOCK
                    rSwap(i,j)
                    cLC(i,i,-elementT.getOne(), elementT.getZero())
                    print "J:"
                    print J
                    print 
                    doneIteration=False
                elif gcd.a < J.get(i,i).a:
                    cLC(i, j, x, y)
                    print "J:"
                    print J
                    print 
                    doneIteration=False
        #print gcd, J.get(i,i)
        assert gcd > elementT.getZero()
        assert gcd == J.get(i,i)
        assert (J is not None) and (str(J) is not None)

        #use the gcd to make all elements int the ith row and the ith
        #column zero by row and column linear combinations
        for j in range(i+1, J.h):
            if J.get(j,i) != elementT.getZero():
                rLC(j,i,elementT.getOne(),-J.get(j,i)/gcd)
                assert(J.get(j,i) == elementT.getZero()), "Actually: %s"%J.get(j,i)
                print "J:"
                print J
                print 
        for j in range(i+1, J.w):
            if J.get(i,j) != elementT.getZero():
                cLC(j,i,elementT.getOne(),-J.get(i,j)/gcd)
                assert(J.get(i,j) == elementT.getZero()), "Actually: %s"%J.get(i,j)
                print "J:"
                print J
                print 

    #At this point J is diagonalized. Me simply need to make sure that every
    #diagonal element divides the element after it
    return J

if __name__ == "__main__":
    contents = [Z(2),Z(9),Z(0),Z(3),Z(0),Z(-6),Z(3),Z(6),Z(-1),Z(6),Z(12),Z(5)]
    A = Matrix(3,4,contents)
    result = snf(A)
    print "S:"
    print str(S)
    print "J:"
    print str(result)
    print "T:"
    print str(T)
    print "S*A*T"
    print S*A*T

    #A = Matrix.inputMatrix()
    #print "You inputted the following matrix: \n"
    #print A
    #print

    #snf(A)
